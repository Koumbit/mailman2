#! /usr/bin/python -O
# $URL$
# $Id$

"""

Fooling lintian that complains about not sourcing confmodule:
. /usr/share/debconf/confmodule
"""


import sys
import os
import bsddb
from errno import ENOENT


## # Argl, if the debconf Python interface were well designed, sth like
## #   from debconf import instance as db
## # should be sufficient here.  As it is, must work around it's flaws.
## def get_debconf_interface(title=''):
##     """Get an debconf interface instance, starting a frontend if
##     none is available.
##     """#
##     from debconf import Debconf, _frontEndProgram
##     try:             junk = os.environ['DEBIAN_HAS_FRONTEND']
##     except KeyError: os.execv(_frontEndProgram, [_frontEndProgram]+sys.argv)
##     return Debconf(title)
## db = get_debconf_interface() ; del get_debconf_interface
## #  Exception class and convenience constants
## from debconf import DebconfError, LOW, MEDIUM, HIGH, CRITICAL


MM_INST = '/usr/lib/mailman'
MM_HOME = '/var/lib/mailman'
MM_BIN  = os.path.join(MM_INST, 'bin')

# mailman (and thus the Mailman py package) may not be installed yet.
sys.path.insert(0, os.path.join(MM_INST, 'Mailman'))
from Debian import DebuggingLogger, mm_languages, cfdb


def ucf_to_cfdb():
    """Import templates under ucf control.

    All Debian releases up to now that used ucf have only registered
    files under /etc/mailman/LANG and /etc/mailman/qmail-to-mailman.py
    with ucf, allowing this simplistic approach at moving to our own
    conffile database.
    """#

    UCF_CACHE = '/var/lib/ucf/cache'
    ETC_DIR   = '/etc/mailman/'
    ETC_LEN   = len(ETC_DIR)

    prev_lang = None

    ucf_list = [ fn for fn in os.listdir(UCF_CACHE)
                 if fn.startswith(':etc:mailman:') ]
    if not ucf_list: return
    
    log('Moving files out of ucf control ', nl='')

    for cached in ucf_list:
        path = '/'.join(cached.split(':'))
        ucf_cached = os.path.join(UCF_CACHE, cached)
        tmpl = open(ucf_cached).read()
        try:
            reg_key = path[ETC_LEN:]
            lang, tmpl = reg_key.split('/')
            if lang in mm_languages:
                if lang != prev_lang:
                    if prev_lang: cfdb.sync()
                    prev_lang = lang
                cfdb.register(reg_key, tmpl)
        except ValueError:
            cfdb.register(path, tmpl)

        os.system('ucf --purge --three-way %(path)s' % locals())
        os.remove(ucf_cached)
        log('.', nl='')

    cfdb.sync()
    log(' done.')


def run_debhelper_additions():

    from popen2 import Popen4
    runner = Popen4('/bin/sh -e')
    runner.tochild.write("""\
#DEBHELPER#""")
    runner.tochild.close()
    while True:
        rc = runner.poll()
        if rc != -1: break
        log(runner.fromchild.readline(), nl='')
    log(runner.fromchild.read(), nl='')
    if rc != 0:
        log('DebHelper added script failed with rc=%(rc)r.' % locals())
        raise SystemExit(1)


if __name__ == '__main__':
    log = DebuggingLogger('MM_MAINT')
    try:
        op = sys.argv[1]
        if op == 'configure':
            ucf_to_cfdb()
        if op in ('configure','abort-upgrade','abort-remove','abort-deconfigure'):
            run_debhelper_additions()
        else:
            log("postinst called with unknown argument %r." % op)
            raise SystemExit(1)
    finally:
        # When things break, this information might be useful
        log.sys_info()

