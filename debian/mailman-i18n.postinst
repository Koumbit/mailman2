#!/usr/bin/python -O
#
# $URL$
# $Id$
#

"""

Fooling lintian that complains about not sourcing confmodule:
. /usr/share/debconf/confmodule
"""#


import sys, os


# Argl, if the debconf Python interface were well designed, sth like
#   from debconf import instance as db
# should be sufficient here.  As it is, must work around it's flaws.
def get_debconf_interface(title=''):
    """Get an debconf interface instance, starting a frontend if
    none is available.
    """#
    from debconf import Debconf, _frontEndProgram
    try:             junk = os.environ['DEBIAN_HAS_FRONTEND']
    except KeyError: os.execv(_frontEndProgram, [_frontEndProgram]+sys.argv)
    return Debconf(title)
db = get_debconf_interface() ; del get_debconf_interface
#  Exception class and convenience constants
from debconf import DebconfError, LOW, MEDIUM, HIGH, CRITICAL


PACKAGE='mailman-i18n'
MM_HOME = '/var/lib/mailman'

sys.path.insert(0, MM_HOME)

from Mailman.Debian import DebuggingLogger, cfdb, mm_languages

from errno import EEXIST, ENOTEMPTY
#from errno import *

mm_etc='/etc/mailman'
mm_tmpl=os.path.join(mm_etc, 'templates')
mm_dist='/usr/share/mailman/templates'


def setup():
    """
    """#

    # Install only languages selected by the administrator
    # forcing used languages to be always available.
    site_languages = db.get('mailman/site_languages').split(', ')
    site_languages = [ s.strip() for s in site_languages if s.strip() ]
    need_languages = site_languages
    used_languages = db.get('mailman/used_languages').split()
    db.fset('mailman/used_languages', 'seen', 'true')
    db.fset('mailman/used_languages', 'scanned', 'false')

    log('DEBCONF: used_languages=%(used_languages)r' % locals(), lvl=2)
    log('DEBCONF: site_languages=%(site_languages)r' % locals(), lvl=2)

    for lang in used_languages:
        if lang not in site_languages:
            need_languages.append(lang)
    if need_languages != site_languages:
        db.set('mailman/site_languages', ', '.join(need_languages))
        site_languages = need_languages

    log('SETUP: need_languages=%(need_languages)r' % locals(), lvl=2)

    remove_templates(need_languages)
    install_templates(need_languages)

    run_debhelper_additions()


def remove_templates(site_languages):
    """
    """#
    old_languages = os.listdir(mm_tmpl)

    for lang in old_languages:
        if lang not in site_languages:
            langdir = os.path.join(mm_tmpl, lang)
            log('Removing unmodified files from %(langdir)s ' % locals(),
                nl='')
            def cb(*args):
                log('.', nl='')
            cfdb.remove_unmod(lang, dst=mm_tmpl, callback=cb)
            cfdb.sync()
            log(' done.')
            try:
                os.rmdir(langdir)
            except OSError,err:
                if err.errno == ENOTEMPTY:
                    log('Directory %(langdir)s not empty so not removed.' % locals())
                else: raise


def install_templates(site_languages):
    """
    """#
    for lang in site_languages:
        log('Installing site language %(lang)s ' % locals(), nl='')
        try:
            os.mkdir(os.path.join(mm_tmpl, lang))
        except OSError, err:
            if err.errno != EEXIST: raise

        for fn in os.listdir(os.path.join(mm_dist, lang)):
            log('.', nl='')
            langfile='%(lang)s/%(fn)s' % locals()
            msg = cfdb.update(langfile, src=mm_dist, dst=mm_tmpl)
            log(msg, lvl=9, nl='\n ')
            # TBD: remove templates no longer distributed
        cfdb.sync()
        log(' done.')

def run_debhelper_additions():
    runit = os.popen('/bin/sh -e', 'w')
    runit.write("""\
#DEBHELPER#""")
    if runit.close() is not None:
        raise SystemExit(1)

if __name__ == '__main__':
    log = DebuggingLogger('MM_MAINT')
    try:
        op = sys.argv[1]
        if op == 'configure':
            setup()
        elif op in ('abort-upgrade','abort-remove','abort-deconfigure'):
            pass
        else:
            log("postinst called with unknown argument \`%s'" % op)
            raise SystemExit(1)
    finally:
        # When things break, this information might be useful
        log.sys_info()
