#! /usr/bin/python -O
# $URL$
# $Id$

"""

Fooling lintian that complains about not sourcing confmodule:
. /usr/share/debconf/confmodule
"""

import sys, os


# Argl, if the debconf Python interface were well designed, sth like
#   from debconf import instance as db
# should be sufficient here.  As it is, must work around it's flaws.
def get_debconf_interface(title=''):
    """Get an debconf interface instance, starting a frontend if
    none is available.
    """#
    from debconf import Debconf, _frontEndProgram
    try:             junk = os.environ['DEBIAN_HAS_FRONTEND']
    except KeyError: os.execv(_frontEndProgram, [_frontEndProgram]+sys.argv)
    return Debconf(title)
db = get_debconf_interface() ; del get_debconf_interface
#  Exception class and convenience constants
from debconf import DebconfError, LOW, MEDIUM, HIGH, CRITICAL


MM_INST = '/usr/lib/mailman'
MM_HOME = '/var/lib/mailman'
MM_BIN  = os.path.join(MM_INST, 'bin')

sys.path.insert(0, MM_INST)

from Mailman.Debian import DebuggingLogger, CommandRunner, cfdb
from errno import ENOENT


def compile_modules(directory):
    """Compiles all python modules in the specified directory.

    
    """#
    from compileall import compile_dir
    ca_script = sys.modules['compileall'].__file__
    opt = ca_script[-1] == 'o'
    ca_script = ca_script[:-1]
    flag, _int, ext  = (opt and ('', ' optimized', '')
                        or (' -O', '', ' optimized'))
    log('Compiling%(_int)s modules ...' % locals(), nl='')
    compile_dir(directory, force=True, quiet=True)
    log(' done.')
    log('Compiling%(ext)s modules ...' % locals(), nl='')
    cmd = 'python%(flag)s %(ca_script)s -f -q %(directory)s' % locals()
    log('\n%r' % cmd, lvl=2, nl='\n... ')
    os.system(cmd)
    log(' done.')



class UCF:
    # Find a better name for this class!
    def __init__(self, hashfile):
        self.hashlines = open(hashfile).readlines()
        self.dirs = {}

    def enum(self, rexp):
        import re
        tmpl_re = re.compile(rexp)
        for line in self.hashlines:
            words = line.split()
            if len(words) != 2: continue
            ucf_md5, path = words
            if not tmpl_re.match(path): continue
            yield ucf_md5, path

    def purge(self, path):
        os.system('ucf --purge %(path)s' % locals())
        try:
            os.remove(path)
        except OSError, e:
            if e.errno != ENOENT: raise
        for ext in ('dist', 'old', 'new'):
            try:
                os.remove('%(path)s.dpkg-%(ext)s' % locals())
            except OSError, e:
                if e.errno != ENOENT: raise
        self.dirs[os.path.dirname(path)] = True

    def rmdirs(self):
        for d, p in self.dirs.items():
            try:
                if p: os.rmdir(d)
            except OSError, e:
                if e.errno == ENOTEMPTY:
                    log('Directory %(d)s not empty, not removed.' % locals())
                elif e.errno != ENOENT: raise
            del self.dirs[d]

        

def templates_from_ucf():
    """Get templates out of ucf control.

    With mailman's own template overriding there is no need for
    local templates in /etc/mailman under ucf control.  Locally
    modified templates are assumed to be site wide modifications.
    """#
    import md5
    from Mailman.Defaults import TEMPLATE_DIR

    def save_site_template(path, data):
        orig_umask = os.umask(002)
        try:
            dst_tmpl = os.path.join(TEMPLATE_DIR, 'site', path[13:])
            try:
                stfl = open(dst_tmpl, 'w')
            except IOError, e:
                if e.errno <> ENOENT: raise
                os.makedirs(os.path.dirname(dst_tmpl), 02775)
                stfl = open(dst_tmpl, 'w')
        finally:
            os.umask(orig_umask)
        try:
            stfl.write(data)
        finally:
            stfl.close()

    ucf = UCF('/var/lib/ucf/hashfile')
    log_cnt = 0
    for ucf_md5, path in ucf.enum('^/etc/mailman/.+/'):
        if log_cnt == 0:
            log('Moving templates out of ucf control ', nl='')
        log_cnt += 1
        try:
            tmpl = open(path).read()
            site_md5 = md5.new(tmpl).hexdigest()
            if site_md5 != ucf_md5:
                save_site_template(path, tmpl)
        except IOError, e:
            if e.errno <> ENOENT: raise
        ucf.purge(path)
        log('.', nl='')
    if log_cnt:
        log(' done.')
    ucf.rmdirs()


def default_mm_cfg():
    """Get configuration defaults.
    """#
    gbls = {}
    exec 'from Mailman.Defaults import *' in gbls
    for k, v in gbls.items():
        try:
            hash(v)
        except TypeError:
            try:
                gbls[k] = v.copy()
            except AttributeError:
                gbls[k] = v[:]
    return gbls


from Mailman.Debian import mm_cfg_defaults, mm_cfg_fillin, \
     mm_cfg_delimiter, mm_cfg_deprecated

def create_mm_cfg():
    """Create an initial /etc/mailman/mm_cfg.py

    This works only for a first time install.
    """#
    try:
        mm_cfg_fl = open('/etc/mailman/mm_cfg.py', 'w')
        # Writing a constant prefix (including the import from Defaults)
        # beforehand makes sure there is a formally working mm_cfg.
        mm_cfg_fl.write(mm_cfg_defaults)
        mm_cfg_fl.flush()

        gbls = default_mm_cfg()

        email_host = db.get('mailman/email_host')
        gbls['DEFAULT_EMAIL_HOST'] = email_host
        log('DEBCONF email_host=%(DEFAULT_EMAIL_HOST)r' % gbls, lvl=2)
        url_host = db.get('mailman/url_host') or 'www.'+email_host
        gbls['DEFAULT_URL_HOST']   = url_host
        log('DEBCONF url_host=%(DEFAULT_URL_HOST)r' % gbls, lvl=2)
        server_language = db.get('mailman/default_server_language') or 'en'
        gbls['DEFAULT_SERVER_LANGUAGE'] = server_language
        exec 'from urlparse import urlsplit' in gbls
        exec 'default_url_path = urlsplit(DEFAULT_URL_PATTERN)[2]' in gbls
        exec 'virtual_hosts = ""' in gbls
        mm_cfg_fl.write(mm_cfg_fillin % gbls)
        mm_cfg_fl.write(mm_cfg_delimiter)
        mm_cfg_fl.close()
    except DebconfError, exc:
        log.exception()


def upgrade_mm_cfg():
    """Update an existing /etc/mailman/mm_cfg.py.

    Given upgrade paths from 2.0 MM installations and somewhat
    broken mm_cfg files from 2.1 installations try to translate
    obsolete variables to their 2.1 counterparts.
    """#
    etc_mm_cfg = '/etc/mailman/mm_cfg.py'
    def_gbls = default_mm_cfg()
    usr_gbls = {}
    sys.modules['Defaults'] = sys.modules['Mailman.Defaults']
    execfile(etc_mm_cfg, usr_gbls)

    # When DEFAULT_URL_HOST has been changed via debconf, its obsolete
    # VIRTUAL_HOSTS entry would be regenerated further down when
    # creating add_virtualhost() calls for non-default entries.
    try: exec 'del VIRTUAL_HOSTS[DEFAULT_URL_HOST]' in usr_gbls
    except: pass

    os.rename(etc_mm_cfg, etc_mm_cfg+'.dpkg-old')

    try:
        from Mailman.Debian import mm_cfg_defaults, mm_cfg_fillin
        mm_cfg_fl = open(etc_mm_cfg, 'w')
        # Writing a constant prefix (including the import from Defaults)
        # beforehand makes sure there is a formally working mm_cfg.
        mm_cfg_fl.write(mm_cfg_defaults)
        mm_cfg_fl.flush()

        email_host = db.get('mailman/email_host')
        usr_gbls['DEFAULT_EMAIL_HOST'] = email_host
        log('DEBCONF email_host=%(DEFAULT_EMAIL_HOST)r' % usr_gbls, lvl=2)
        url_host = db.get('mailman/url_host') or 'www.'+email_host
        usr_gbls['DEFAULT_URL_HOST']   = url_host
        log('DEBCONF url_host=%(DEFAULT_URL_HOST)r' % usr_gbls, lvl=2)
        server_language = db.get('mailman/default_server_language') or 'en'
        usr_gbls['DEFAULT_SERVER_LANGUAGE'] = server_language

        from urlparse import urlsplit, urlunsplit
        if usr_gbls['DEFAULT_URL'] is not None:
            scheme, host, path = urlsplit(usr_gbls['DEFAULT_URL'])[:3]
            usr_gbls['DEFAULT_URL_PATTERN'] = urlunsplit((scheme, '%s', path, '', ''))

        usr_mod  = {}
        usr_def  = {}

        for var, usr_value in usr_gbls.items():
            try:
                if usr_value != def_gbls[var]:
                    usr_mod[var] = 1
            except KeyError:
                # Handle user defined variable here
                usr_def[var] = 1

        del usr_def['__doc__']

        if usr_mod.keys():
            log("User modified variables:", lvl=3)
            for var in usr_mod.keys():
                log('  %20s: %r\n  %20s: %r'
                    % (var, usr_gbls[var], 'default', def_gbls[var]), lvl=3)

        if usr_def.keys():
            log("User defined variables:", lvl=3)
            for var in usr_def.keys():
                log('  %20s: %r' % (var, usr_gbls[var]), lvl=3)

        def_scheme, def_netloc, def_path = urlsplit(def_gbls['DEFAULT_URL_PATTERN'])[:3]
        if 'DEFAULT_URL_PATTERN' in usr_mod.keys():
            usr_scheme, usr_netloc, usr_path = urlsplit(usr_gbls['DEFAULT_URL_PATTERN'])[:3]
            usr_gbls['default_url_path'] = usr_path
        else:    
            usr_gbls['default_url_path'] = def_path

        if 'IMAGE_LOGOS' in usr_mod.keys():
            if usr_gbls['IMAGE_LOGOS'].startswith('/doc/mailman'):
                exec 'OLD_IMAGE_LOGOS = IMAGE_LOGOS' in usr_gbls
                usr_def['OLD_IMAGE_LOGOS'] = 1
                usr_gbls['IMAGE_LOGOS'] = def_gbls['IMAGE_LOGOS']
        if 'PUBLIC_ARCHIVE_URL' in usr_mod.keys():
            exec 'OLD_PUBLIC_ARCHIVE_URL = PUBLIC_ARCHIVE_URL' in usr_gbls
            exec 'PUBLIC_ARCHIVE_URL=%(PUBLIC_ARCHIVE_URL)r' % def_gbls in usr_gbls
            usr_def['OLD_PUBLIC_ARCHIVE_URL'] = 1
        exec 'DEFAULT_SEND_REMINDERS = DEFAULT_SEND_REMINDERS and True or False' in usr_gbls
        exec 'USE_ENVELOPE_SENDER = USE_ENVELOPE_SENDER and True or False' in usr_gbls

        from cStringIO import StringIO

        # Make sure user added virtual hosts are kept in the new mm_cfg
        vhosts = StringIO()
        for url_host, email_host in usr_gbls['VIRTUAL_HOSTS'].items():
            if (url_host, email_host) not in ((usr_gbls['DEFAULT_URL_HOST'],
                                               usr_gbls['DEFAULT_EMAIL_HOST']),
                                              ('localhost', 'localhost')):
                vhosts.write('\nadd_virtualhost(%(url_host)r, %(email_host)r)' % locals())
        usr_gbls['virtual_hosts'] = vhosts.getvalue()

        # Generate commented /etc/mailman/mm_cfg.py.dpkg-dist
        cfl = StringIO()
        cfl.write(mm_cfg_fillin % usr_gbls)

        # Add delimiter indicating end of automatically handled section
        cfl.write(mm_cfg_delimiter)

        # Isolate deprecated variables 
        from Mailman.Debian import mm_cfg_deprecated

        deprecated = StringIO()
        deprecated_vars = mm_cfg_deprecated.keys()
        deprecated_vars.sort()
        usr_mod.update(usr_def)
        for v in deprecated_vars:
            try:
                usr_mod[v]
                deprecated.write(mm_cfg_deprecated[v] % usr_gbls)
                del usr_def[v]
            except KeyError: pass

        defs = usr_def.keys()
        if defs:
            cfl.write('\n#%s\n' % ('-'*71))
            cfl.write('# The following variables have no defaults defined in '
                      '%(PREFIX)s/Mailman/Defaults\n' % usr_gbls)
            defs.sort()
            for v in defs:
                fmt = '%(v)s = %%(%(v)s)r\n' % locals()
                cfl.write(fmt % usr_gbls)


        s = deprecated.getvalue()
        if s:
                cfl.write(mm_cfg_deprecated[None])
                cfl.write(s)

        mm_cfg_fl.write(cfl.getvalue())
        mm_cfg_fl.close()
    except DebconfError, exc:
        log.exception()


def update_cron():
    """Update mailman crontab according to debconf setting.

    Additionally, if we are upgrading from a MM version using
    /usr/lib/mailman, change pathes in crontab to
    /var/lib/mailman.
    """#
    from Mailman.Debian import mm_crontab

    gate_news = db.getBoolean('mailman/gate_news')
    log('DEBCONF gate_news=%(gate_news)r' % locals(), lvl=2)
    cron_tab = '/etc/cron.d/mailman'

    try:
        old_crontab = open(cron_tab).read()
        cur_crontab = apply_gate_news(old_crontab, gate_news)
        if cur_crontab != old_crontab:
            open(cron_tab, 'w').write(cur_crontab)
    except IOError, err:
        if err.errno != ENOENT: raise

    new_crontab = apply_gate_news(mm_crontab, gate_news)

    # Make sure cfdb comparision use identical gate_news settings
    try:
        cfdb[cron_tab] = apply_gate_news(cfdb[cron_tab], gate_news)
    except KeyError:
        cfdb.register(cron_tab, new_crontab)

    msg = cfdb.update(cron_tab, data=new_crontab)
    log(msg, lvl=2)



def apply_gate_news(crontab, gate_news):
    """Apply gate_news setting to crontab string"""
    lines = crontab.split('\n')
    cron_lines = []
    for line in lines:
        if line.find('/usr/lib/mailman/cron/gate_news') > 0:
            prefix = (gate_news and [''] or ['# '])[0]
            line = prefix + uncomment(line)
        cron_lines.append(line)
    return '\n'.join(cron_lines)


def uncomment(line):
    line = line.lstrip()
    while line[0] == '#':
        line = line[1:].lstrip()
    return line


def fix_perms():
    """Fix directory permissions to allow write access to group list.
    """#
    log('Fixing permissions ...', nl='', lvl=2)
    check_perms = os.path.join(MM_BIN, 'check_perms')
    rc = CommandRunner(MM_BIN).run(check_perms, '-f', '-q')
    if rc:
        log(' done, rc=%r.' % rc, lvl=2)
    else:
        log(' done.', lvl=2)
    return rc


def update_lists():
    """Update mailing list configurations.
    """#
    log('Updating existing mailing lists ...', nl='', lvl=2)
    update = os.path.join(MM_BIN, 'update')
    rc = CommandRunner(MM_BIN).run(update)
    if rc:
        log(' done, rc=%r.' % rc, lvl=2)
    else:
        log(' done.', lvl=2)
    return rc


def start_mm_qrunner():
    log('>> entering start_mm_qrunner', lvl=3)

    from popen2 import Popen4
    runner = Popen4('/bin/sh -e')
    runner.tochild.write("""\
#DEBHELPER#""")
    runner.tochild.close()
    while True:
        rc = runner.poll()
        if rc != -1: break
        log(runner.fromchild.readline(), nl='')
    log(runner.fromchild.read(), nl='')
    if rc != 0:
        log('DebHelper added script failed with rc=%(rc)r.' % locals())
        raise SystemExit(1)


def setup():
    compile_modules(MM_INST)
    templates_from_ucf()
    if os.path.exists('/etc/mailman/mm_cfg.py'):
        upgrade_mm_cfg()
    else:
        create_mm_cfg()
    update_cron()
    db.stop()
    fix_perms()
    update_lists()


if __name__ == '__main__':
    log = DebuggingLogger('MM_MAINT')
    try:
        op = sys.argv[1]
        if op == 'configure':
            setup()
        if op in ('configure','abort-upgrade','abort-remove','abort-deconfigure'):
            start_mm_qrunner()
        else:
            log("postinst called with unknown argument %r." % op)
            raise SystemExit(1)
        sys.exit(0)
    finally:
        # When things break, this information might be useful
        log.sys_info()

