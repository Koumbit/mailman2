#! /usr/bin/python -O
# $URL$
# $Id$

"""

Fooling lintian that complains about not sourcing confmodule:
. /usr/share/debconf/confmodule
"""


import sys, os


# Argl, if the debconf Python interface were well designed, sth like
#   from debconf import instance as db
# should be sufficient here.  As it is, must work around it's flaws.
def get_debconf_interface(title=''):
    """Get an debconf interface instance, starting a frontend if
    none is available.
    """#
    from debconf import Debconf, _frontEndProgram
    try:             junk = os.environ['DEBIAN_HAS_FRONTEND']
    except KeyError: os.execv(_frontEndProgram, [_frontEndProgram]+sys.argv)
    return Debconf(title)
db = get_debconf_interface() ; del get_debconf_interface
#  Exception class and convenience constants
from debconf import DebconfError, LOW, MEDIUM, HIGH, CRITICAL


MM_HOME = '/var/lib/mailman'

sys.path.insert(0, MM_HOME)

from Mailman.Debian import DebuggingLogger, CommandRunner

MM_BIN  = os.path.join(MM_HOME, 'bin')
MM_INST = '/usr/share/mailman'


def ucf_to_cfdb():
    """Import templates under ucf control.

    All Debian releases up to now that used ucf have only registered
    files under /etc/mailman/LANG and /etc/mailman/qmail-to-mailman.py
    with ucf, allowing this simplistic approach at moving to our own
    conffile database.
    """#
    from Mailman.Debian import cfdb, mm_languages

    UCF_CACHE = '/var/lib/ucf/cache'
    ETC_DIR   = '/etc/mailman/'
    ETC_LEN   = len(ETC_DIR)

    prev_lang = None

    ucf_list = [ fn for fn in os.listdir(UCF_CACHE)
                 if fn.startswith(':etc:mailman:') ]
    if not ucf_list: return
    
    log('Moving files out of ucf control ', nl='')

    for cached in ucf_list:
        path = '/'.join(cached.split(':'))
        ucf_cached = os.path.join(UCF_CACHE, cached)
        tmpl = open(ucf_cached).read()
        try:
            reg_key = path[ETC_LEN:]
            lang, tmpl = reg_key.split('/')
            if lang in mm_languages:
                if lang != prev_lang:
                    if prev_lang: cfdb.sync()
                    prev_lang = lang
                cfdb.register(reg_key, tmpl)
        except ValueError:
            cfdb.register(path, tmpl)

        os.system('ucf --purge --three-way %(path)s' % locals())
        os.remove(ucf_cached)
        log('.', nl='')

    cfdb.sync()
    log(' done.')


def compile_modules(directory):
    """Compiles all python modules in the specified directory.

    
    """#
    from compileall import compile_dir
    ca_script = sys.modules['compileall'].__file__
    opt = ca_script[-1] == 'o'
    ca_script = ca_script[:-1]
    flag, _int, ext  = (opt and ('', ' optimized', '')
                        or (' -O', '', ' optimized'))
    log('Compiling%(_int)s modules ...' % locals(), nl='')
    compile_dir(directory, force=True, quiet=True)
    log(' done.')
    log('Compiling%(ext)s modules ...' % locals(), nl='')
    cmd = 'python%(flag)s %(ca_script)s -f -q %(directory)s' % locals()
    log('\n%r' % cmd, lvl=2, nl='\n... ')
    os.system(cmd)
    log(' done.')


def create_mm_cfg():
    """Create an initial /etc/mailman/mm_cfg.py

    This works only for a first time install.
    """#
    try:
        gbls = globals().copy()

        from Mailman.Debian import mm_cfg_defaults, mm_cfg_fillin
        mm_cfg_fl = open('/etc/mailman/mm_cfg.py', 'w')
        # Writing a constant prefix (including the import from Defaults)
        # beforehand makes sure there is a formally working mm_cfg.
        mm_cfg_fl.write(mm_cfg_defaults)
        mm_cfg_fl.flush()

        exec 'from Mailman.Defaults import *' in gbls

        email_host = db.get('mailman/email_host')
        gbls['DEFAULT_EMAIL_HOST'] = email_host
        log('DEBCONF email_host=%(DEFAULT_EMAIL_HOST)r' % gbls, lvl=2)
        url_host = db.get('mailman/url_host') or 'www.'+email_host
        gbls['DEFAULT_URL_HOST']   = url_host
        log('DEBCONF url_host=%(DEFAULT_URL_HOST)r' % gbls, lvl=2)
        mm_cfg_fl.write(mm_cfg_fillin % gbls)
        mm_cfg_fl.close()
    except DebconfError, exc:
        log.exception()


def update_cron():
    """Update mailman crontab according to debconf setting.

    Additionally, if we are upgrading from a MM version using
    /usr/lib/mailman, change pathes in crontab to
    /var/lib/mailman.
    """#
    gate_news = db.getBoolean('mailman/gate_news')
    log('DEBCONF gate_news=%(gate_news)r' % locals(), lvl=2)
    cron_tab = '/etc/cron.d/mailman'
    cron_dir = os.path.join(MM_HOME, 'cron')
    gn_path = os.path.join(cron_dir, 'gate_news')
    ctf = open(cron_tab, 'r+')
    changed_pathes = False
    cron_lines = []
    for line in ctf.readlines():
        pos = line.find('/usr/lib/mailman')
        if pos != -1:
            changed_pathes = True
            line = line[:pos] + '/var' + line[pos+4:]
        if line.find(gn_path) > 0:
            prefix = ''
            if not gate_news:
                prefix = '# '
            line = prefix + uncomment(line)
        cron_lines.append(line)
    ctf.seek(0)
    ctf.truncate()
    for line in cron_lines:
        ctf.write(line)
    ctf.close()
    if changed_pathes:
        log('Changed pathes in %(cron_tab)r to %(cron_dir)r.'
            % locals())
    # FIXME: keep track of changes?


def uncomment(line):
    line = line.lstrip()
    while line[0] == '#':
        line = line[1:].lstrip()
    return line


def run_debhelper_additions():
    runit = os.popen('/bin/sh -e', 'w')
    runit.write("""\
#DEBHELPER#""")
    if runit.close() is not None:
        raise SystemExit(1)


def setup():
    compile_modules(MM_HOME)
    ucf_to_cfdb()
    create_mm_cfg()
    update_cron()
    run_debhelper_additions()


if __name__ == '__main__':
    log = DebuggingLogger('MM_MAINT')
    try:
        function    = sys.argv[1]
        inst_version = sys.argv[2]
        if function in ('configure',):
            setup()
    finally:
        # When things break, this information might be useful
        log.sys_info()

